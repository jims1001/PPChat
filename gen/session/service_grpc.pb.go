// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.29.3
// source: session/service.proto

package sessionpb

import (
	message "PProject/gen/message"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	RealtimeService_Connect_FullMethodName   = "/message.v1.RealtimeService/Connect"
	RealtimeService_Publish_FullMethodName   = "/message.v1.RealtimeService/Publish"
	RealtimeService_Subscribe_FullMethodName = "/message.v1.RealtimeService/Subscribe"
	RealtimeService_Ack_FullMethodName       = "/message.v1.RealtimeService/Ack"
)

// RealtimeServiceClient is the client API for RealtimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========== 一、实时通道（帧级双向流） ==========
type RealtimeServiceClient interface {
	// 双向流：客户端发送/接收 SendMessageFrame（含 DATA/ACK/事件等）
	Connect(ctx context.Context, opts ...grpc.CallOption) (RealtimeService_ConnectClient, error)
	// 仅发布一帧（服务端负责分发/入库/通知）；适合 HTTP/gRPC Unary 发布
	Publish(ctx context.Context, in *message.MessageFrameData, opts ...grpc.CallOption) (*message.AckData, error)
	// 订阅事件（按 intents/guild/channel/thread 过滤），服务端推送帧
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (RealtimeService_SubscribeClient, error)
	// 发送确认（独立ACK路径，可配合 QoS=AT_LEAST_ONCE）
	Ack(ctx context.Context, in *message.AckData, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type realtimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRealtimeServiceClient(cc grpc.ClientConnInterface) RealtimeServiceClient {
	return &realtimeServiceClient{cc}
}

func (c *realtimeServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (RealtimeService_ConnectClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RealtimeService_ServiceDesc.Streams[0], RealtimeService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &realtimeServiceConnectClient{ClientStream: stream}
	return x, nil
}

type RealtimeService_ConnectClient interface {
	Send(*message.MessageFrameData) error
	Recv() (*message.MessageFrameData, error)
	grpc.ClientStream
}

type realtimeServiceConnectClient struct {
	grpc.ClientStream
}

func (x *realtimeServiceConnectClient) Send(m *message.MessageFrameData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *realtimeServiceConnectClient) Recv() (*message.MessageFrameData, error) {
	m := new(message.MessageFrameData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *realtimeServiceClient) Publish(ctx context.Context, in *message.MessageFrameData, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, RealtimeService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *realtimeServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (RealtimeService_SubscribeClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RealtimeService_ServiceDesc.Streams[1], RealtimeService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &realtimeServiceSubscribeClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RealtimeService_SubscribeClient interface {
	Recv() (*message.MessageFrameData, error)
	grpc.ClientStream
}

type realtimeServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *realtimeServiceSubscribeClient) Recv() (*message.MessageFrameData, error) {
	m := new(message.MessageFrameData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *realtimeServiceClient) Ack(ctx context.Context, in *message.AckData, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RealtimeService_Ack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RealtimeServiceServer is the server API for RealtimeService service.
// All implementations must embed UnimplementedRealtimeServiceServer
// for forward compatibility
//
// ========== 一、实时通道（帧级双向流） ==========
type RealtimeServiceServer interface {
	// 双向流：客户端发送/接收 SendMessageFrame（含 DATA/ACK/事件等）
	Connect(RealtimeService_ConnectServer) error
	// 仅发布一帧（服务端负责分发/入库/通知）；适合 HTTP/gRPC Unary 发布
	Publish(context.Context, *message.MessageFrameData) (*message.AckData, error)
	// 订阅事件（按 intents/guild/channel/thread 过滤），服务端推送帧
	Subscribe(*SubscribeRequest, RealtimeService_SubscribeServer) error
	// 发送确认（独立ACK路径，可配合 QoS=AT_LEAST_ONCE）
	Ack(context.Context, *message.AckData) (*emptypb.Empty, error)
	mustEmbedUnimplementedRealtimeServiceServer()
}

// UnimplementedRealtimeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRealtimeServiceServer struct {
}

func (UnimplementedRealtimeServiceServer) Connect(RealtimeService_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedRealtimeServiceServer) Publish(context.Context, *message.MessageFrameData) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedRealtimeServiceServer) Subscribe(*SubscribeRequest, RealtimeService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedRealtimeServiceServer) Ack(context.Context, *message.AckData) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedRealtimeServiceServer) mustEmbedUnimplementedRealtimeServiceServer() {}

// UnsafeRealtimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RealtimeServiceServer will
// result in compilation errors.
type UnsafeRealtimeServiceServer interface {
	mustEmbedUnimplementedRealtimeServiceServer()
}

func RegisterRealtimeServiceServer(s grpc.ServiceRegistrar, srv RealtimeServiceServer) {
	s.RegisterService(&RealtimeService_ServiceDesc, srv)
}

func _RealtimeService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RealtimeServiceServer).Connect(&realtimeServiceConnectServer{ServerStream: stream})
}

type RealtimeService_ConnectServer interface {
	Send(*message.MessageFrameData) error
	Recv() (*message.MessageFrameData, error)
	grpc.ServerStream
}

type realtimeServiceConnectServer struct {
	grpc.ServerStream
}

func (x *realtimeServiceConnectServer) Send(m *message.MessageFrameData) error {
	return x.ServerStream.SendMsg(m)
}

func (x *realtimeServiceConnectServer) Recv() (*message.MessageFrameData, error) {
	m := new(message.MessageFrameData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RealtimeService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(message.MessageFrameData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RealtimeServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RealtimeService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RealtimeServiceServer).Publish(ctx, req.(*message.MessageFrameData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RealtimeService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RealtimeServiceServer).Subscribe(m, &realtimeServiceSubscribeServer{ServerStream: stream})
}

type RealtimeService_SubscribeServer interface {
	Send(*message.MessageFrameData) error
	grpc.ServerStream
}

type realtimeServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *realtimeServiceSubscribeServer) Send(m *message.MessageFrameData) error {
	return x.ServerStream.SendMsg(m)
}

func _RealtimeService_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(message.AckData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RealtimeServiceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RealtimeService_Ack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RealtimeServiceServer).Ack(ctx, req.(*message.AckData))
	}
	return interceptor(ctx, in, info, handler)
}

// RealtimeService_ServiceDesc is the grpc.ServiceDesc for RealtimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RealtimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.v1.RealtimeService",
	HandlerType: (*RealtimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _RealtimeService_Publish_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _RealtimeService_Ack_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _RealtimeService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _RealtimeService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "session/service.proto",
}

const (
	MessageService_Send_FullMethodName        = "/message.v1.MessageService/Send"
	MessageService_BatchSend_FullMethodName   = "/message.v1.MessageService/BatchSend"
	MessageService_Edit_FullMethodName        = "/message.v1.MessageService/Edit"
	MessageService_Delete_FullMethodName      = "/message.v1.MessageService/Delete"
	MessageService_Recall_FullMethodName      = "/message.v1.MessageService/Recall"
	MessageService_React_FullMethodName       = "/message.v1.MessageService/React"
	MessageService_MarkRead_FullMethodName    = "/message.v1.MessageService/MarkRead"
	MessageService_ListHistory_FullMethodName = "/message.v1.MessageService/ListHistory"
	MessageService_GetMessage_FullMethodName  = "/message.v1.MessageService/GetMessage"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========== 二、消息服务（面向 MessageData 的业务接口） ==========
type MessageServiceClient interface {
	// 发送单条消息（服务端封装为帧并分发）。建议携带 dedup_id / ack_id。
	Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*SendResp, error)
	// 批量发送
	BatchSend(ctx context.Context, in *BatchSendReq, opts ...grpc.CallOption) (*BatchSendResp, error)
	// 编辑消息
	Edit(ctx context.Context, in *EditMessageReq, opts ...grpc.CallOption) (*message.AckData, error)
	// 删除（本地可见删除）
	Delete(ctx context.Context, in *DeleteMessageReq, opts ...grpc.CallOption) (*message.AckData, error)
	// 撤回（对端不可见）
	Recall(ctx context.Context, in *RecallReq, opts ...grpc.CallOption) (*message.AckData, error)
	// 反应（表情/赞等）
	React(ctx context.Context, in *ReactReq, opts ...grpc.CallOption) (*message.AckData, error)
	// 标记已读
	MarkRead(ctx context.Context, in *MarkReadReq, opts ...grpc.CallOption) (*message.AckData, error)
	// 历史列表（会话或频道/线程）
	ListHistory(ctx context.Context, in *ListHistoryReq, opts ...grpc.CallOption) (*ListHistoryResp, error)
	// 获取单条消息
	GetMessage(ctx context.Context, in *GetMessageReq, opts ...grpc.CallOption) (*message.MessageData, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*SendResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendResp)
	err := c.cc.Invoke(ctx, MessageService_Send_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) BatchSend(ctx context.Context, in *BatchSendReq, opts ...grpc.CallOption) (*BatchSendResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchSendResp)
	err := c.cc.Invoke(ctx, MessageService_BatchSend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Edit(ctx context.Context, in *EditMessageReq, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, MessageService_Edit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Delete(ctx context.Context, in *DeleteMessageReq, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, MessageService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Recall(ctx context.Context, in *RecallReq, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, MessageService_Recall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) React(ctx context.Context, in *ReactReq, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, MessageService_React_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) MarkRead(ctx context.Context, in *MarkReadReq, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, MessageService_MarkRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) ListHistory(ctx context.Context, in *ListHistoryReq, opts ...grpc.CallOption) (*ListHistoryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHistoryResp)
	err := c.cc.Invoke(ctx, MessageService_ListHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetMessage(ctx context.Context, in *GetMessageReq, opts ...grpc.CallOption) (*message.MessageData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.MessageData)
	err := c.cc.Invoke(ctx, MessageService_GetMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility
//
// ========== 二、消息服务（面向 MessageData 的业务接口） ==========
type MessageServiceServer interface {
	// 发送单条消息（服务端封装为帧并分发）。建议携带 dedup_id / ack_id。
	Send(context.Context, *SendReq) (*SendResp, error)
	// 批量发送
	BatchSend(context.Context, *BatchSendReq) (*BatchSendResp, error)
	// 编辑消息
	Edit(context.Context, *EditMessageReq) (*message.AckData, error)
	// 删除（本地可见删除）
	Delete(context.Context, *DeleteMessageReq) (*message.AckData, error)
	// 撤回（对端不可见）
	Recall(context.Context, *RecallReq) (*message.AckData, error)
	// 反应（表情/赞等）
	React(context.Context, *ReactReq) (*message.AckData, error)
	// 标记已读
	MarkRead(context.Context, *MarkReadReq) (*message.AckData, error)
	// 历史列表（会话或频道/线程）
	ListHistory(context.Context, *ListHistoryReq) (*ListHistoryResp, error)
	// 获取单条消息
	GetMessage(context.Context, *GetMessageReq) (*message.MessageData, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMessageServiceServer struct {
}

func (UnimplementedMessageServiceServer) Send(context.Context, *SendReq) (*SendResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedMessageServiceServer) BatchSend(context.Context, *BatchSendReq) (*BatchSendResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSend not implemented")
}
func (UnimplementedMessageServiceServer) Edit(context.Context, *EditMessageReq) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Edit not implemented")
}
func (UnimplementedMessageServiceServer) Delete(context.Context, *DeleteMessageReq) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMessageServiceServer) Recall(context.Context, *RecallReq) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recall not implemented")
}
func (UnimplementedMessageServiceServer) React(context.Context, *ReactReq) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method React not implemented")
}
func (UnimplementedMessageServiceServer) MarkRead(context.Context, *MarkReadReq) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkRead not implemented")
}
func (UnimplementedMessageServiceServer) ListHistory(context.Context, *ListHistoryReq) (*ListHistoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHistory not implemented")
}
func (UnimplementedMessageServiceServer) GetMessage(context.Context, *GetMessageReq) (*message.MessageData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessage not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Send(ctx, req.(*SendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_BatchSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).BatchSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_BatchSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).BatchSend(ctx, req.(*BatchSendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Edit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Edit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Edit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Edit(ctx, req.(*EditMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Delete(ctx, req.(*DeleteMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Recall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Recall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_Recall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Recall(ctx, req.(*RecallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_React_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).React(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_React_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).React(ctx, req.(*ReactReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_MarkRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).MarkRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_MarkRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).MarkRead(ctx, req.(*MarkReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_ListHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).ListHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_ListHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).ListHistory(ctx, req.(*ListHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_GetMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetMessage(ctx, req.(*GetMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.v1.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _MessageService_Send_Handler,
		},
		{
			MethodName: "BatchSend",
			Handler:    _MessageService_BatchSend_Handler,
		},
		{
			MethodName: "Edit",
			Handler:    _MessageService_Edit_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MessageService_Delete_Handler,
		},
		{
			MethodName: "Recall",
			Handler:    _MessageService_Recall_Handler,
		},
		{
			MethodName: "React",
			Handler:    _MessageService_React_Handler,
		},
		{
			MethodName: "MarkRead",
			Handler:    _MessageService_MarkRead_Handler,
		},
		{
			MethodName: "ListHistory",
			Handler:    _MessageService_ListHistory_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _MessageService_GetMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session/service.proto",
}

const (
	CollabService_PerformAction_FullMethodName    = "/message.v1.CollabService/PerformAction"
	CollabService_SubscribeActions_FullMethodName = "/message.v1.CollabService/SubscribeActions"
)

// CollabServiceClient is the client API for CollabService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========== 三、协作服务（ActionEnvelope 动作 & 订阅） ==========
type CollabServiceClient interface {
	// 执行动作（投票/表单/任务/文档增量等）
	PerformAction(ctx context.Context, in *message.ActionEnvelope, opts ...grpc.CallOption) (*message.ActionAck, error)
	// 订阅动作（类别/类型过滤）
	SubscribeActions(ctx context.Context, in *message.ActionSubscribe, opts ...grpc.CallOption) (CollabService_SubscribeActionsClient, error)
}

type collabServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCollabServiceClient(cc grpc.ClientConnInterface) CollabServiceClient {
	return &collabServiceClient{cc}
}

func (c *collabServiceClient) PerformAction(ctx context.Context, in *message.ActionEnvelope, opts ...grpc.CallOption) (*message.ActionAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.ActionAck)
	err := c.cc.Invoke(ctx, CollabService_PerformAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collabServiceClient) SubscribeActions(ctx context.Context, in *message.ActionSubscribe, opts ...grpc.CallOption) (CollabService_SubscribeActionsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CollabService_ServiceDesc.Streams[0], CollabService_SubscribeActions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &collabServiceSubscribeActionsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CollabService_SubscribeActionsClient interface {
	Recv() (*message.ActionEnvelope, error)
	grpc.ClientStream
}

type collabServiceSubscribeActionsClient struct {
	grpc.ClientStream
}

func (x *collabServiceSubscribeActionsClient) Recv() (*message.ActionEnvelope, error) {
	m := new(message.ActionEnvelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CollabServiceServer is the server API for CollabService service.
// All implementations must embed UnimplementedCollabServiceServer
// for forward compatibility
//
// ========== 三、协作服务（ActionEnvelope 动作 & 订阅） ==========
type CollabServiceServer interface {
	// 执行动作（投票/表单/任务/文档增量等）
	PerformAction(context.Context, *message.ActionEnvelope) (*message.ActionAck, error)
	// 订阅动作（类别/类型过滤）
	SubscribeActions(*message.ActionSubscribe, CollabService_SubscribeActionsServer) error
	mustEmbedUnimplementedCollabServiceServer()
}

// UnimplementedCollabServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCollabServiceServer struct {
}

func (UnimplementedCollabServiceServer) PerformAction(context.Context, *message.ActionEnvelope) (*message.ActionAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformAction not implemented")
}
func (UnimplementedCollabServiceServer) SubscribeActions(*message.ActionSubscribe, CollabService_SubscribeActionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeActions not implemented")
}
func (UnimplementedCollabServiceServer) mustEmbedUnimplementedCollabServiceServer() {}

// UnsafeCollabServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CollabServiceServer will
// result in compilation errors.
type UnsafeCollabServiceServer interface {
	mustEmbedUnimplementedCollabServiceServer()
}

func RegisterCollabServiceServer(s grpc.ServiceRegistrar, srv CollabServiceServer) {
	s.RegisterService(&CollabService_ServiceDesc, srv)
}

func _CollabService_PerformAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(message.ActionEnvelope)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollabServiceServer).PerformAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CollabService_PerformAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollabServiceServer).PerformAction(ctx, req.(*message.ActionEnvelope))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollabService_SubscribeActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(message.ActionSubscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CollabServiceServer).SubscribeActions(m, &collabServiceSubscribeActionsServer{ServerStream: stream})
}

type CollabService_SubscribeActionsServer interface {
	Send(*message.ActionEnvelope) error
	grpc.ServerStream
}

type collabServiceSubscribeActionsServer struct {
	grpc.ServerStream
}

func (x *collabServiceSubscribeActionsServer) Send(m *message.ActionEnvelope) error {
	return x.ServerStream.SendMsg(m)
}

// CollabService_ServiceDesc is the grpc.ServiceDesc for CollabService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CollabService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.v1.CollabService",
	HandlerType: (*CollabServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PerformAction",
			Handler:    _CollabService_PerformAction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeActions",
			Handler:       _CollabService_SubscribeActions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "session/service.proto",
}

const (
	PresenceService_UpdatePresence_FullMethodName    = "/message.v1.PresenceService/UpdatePresence"
	PresenceService_Typing_FullMethodName            = "/message.v1.PresenceService/Typing"
	PresenceService_SubscribePresence_FullMethodName = "/message.v1.PresenceService/SubscribePresence"
)

// PresenceServiceClient is the client API for PresenceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========== 四、在线状态/输入中 ==========
type PresenceServiceClient interface {
	UpdatePresence(ctx context.Context, in *message.PresenceUpdate, opts ...grpc.CallOption) (*message.AckData, error)
	Typing(ctx context.Context, in *message.TypingStart, opts ...grpc.CallOption) (*message.AckData, error)
	SubscribePresence(ctx context.Context, in *PresenceSubscribeReq, opts ...grpc.CallOption) (PresenceService_SubscribePresenceClient, error)
}

type presenceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPresenceServiceClient(cc grpc.ClientConnInterface) PresenceServiceClient {
	return &presenceServiceClient{cc}
}

func (c *presenceServiceClient) UpdatePresence(ctx context.Context, in *message.PresenceUpdate, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, PresenceService_UpdatePresence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *presenceServiceClient) Typing(ctx context.Context, in *message.TypingStart, opts ...grpc.CallOption) (*message.AckData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(message.AckData)
	err := c.cc.Invoke(ctx, PresenceService_Typing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *presenceServiceClient) SubscribePresence(ctx context.Context, in *PresenceSubscribeReq, opts ...grpc.CallOption) (PresenceService_SubscribePresenceClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PresenceService_ServiceDesc.Streams[0], PresenceService_SubscribePresence_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &presenceServiceSubscribePresenceClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PresenceService_SubscribePresenceClient interface {
	Recv() (*message.PresenceUpdate, error)
	grpc.ClientStream
}

type presenceServiceSubscribePresenceClient struct {
	grpc.ClientStream
}

func (x *presenceServiceSubscribePresenceClient) Recv() (*message.PresenceUpdate, error) {
	m := new(message.PresenceUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PresenceServiceServer is the server API for PresenceService service.
// All implementations must embed UnimplementedPresenceServiceServer
// for forward compatibility
//
// ========== 四、在线状态/输入中 ==========
type PresenceServiceServer interface {
	UpdatePresence(context.Context, *message.PresenceUpdate) (*message.AckData, error)
	Typing(context.Context, *message.TypingStart) (*message.AckData, error)
	SubscribePresence(*PresenceSubscribeReq, PresenceService_SubscribePresenceServer) error
	mustEmbedUnimplementedPresenceServiceServer()
}

// UnimplementedPresenceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPresenceServiceServer struct {
}

func (UnimplementedPresenceServiceServer) UpdatePresence(context.Context, *message.PresenceUpdate) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePresence not implemented")
}
func (UnimplementedPresenceServiceServer) Typing(context.Context, *message.TypingStart) (*message.AckData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Typing not implemented")
}
func (UnimplementedPresenceServiceServer) SubscribePresence(*PresenceSubscribeReq, PresenceService_SubscribePresenceServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribePresence not implemented")
}
func (UnimplementedPresenceServiceServer) mustEmbedUnimplementedPresenceServiceServer() {}

// UnsafePresenceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PresenceServiceServer will
// result in compilation errors.
type UnsafePresenceServiceServer interface {
	mustEmbedUnimplementedPresenceServiceServer()
}

func RegisterPresenceServiceServer(s grpc.ServiceRegistrar, srv PresenceServiceServer) {
	s.RegisterService(&PresenceService_ServiceDesc, srv)
}

func _PresenceService_UpdatePresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(message.PresenceUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PresenceServiceServer).UpdatePresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PresenceService_UpdatePresence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PresenceServiceServer).UpdatePresence(ctx, req.(*message.PresenceUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _PresenceService_Typing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(message.TypingStart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PresenceServiceServer).Typing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PresenceService_Typing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PresenceServiceServer).Typing(ctx, req.(*message.TypingStart))
	}
	return interceptor(ctx, in, info, handler)
}

func _PresenceService_SubscribePresence_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PresenceSubscribeReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PresenceServiceServer).SubscribePresence(m, &presenceServiceSubscribePresenceServer{ServerStream: stream})
}

type PresenceService_SubscribePresenceServer interface {
	Send(*message.PresenceUpdate) error
	grpc.ServerStream
}

type presenceServiceSubscribePresenceServer struct {
	grpc.ServerStream
}

func (x *presenceServiceSubscribePresenceServer) Send(m *message.PresenceUpdate) error {
	return x.ServerStream.SendMsg(m)
}

// PresenceService_ServiceDesc is the grpc.ServiceDesc for PresenceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PresenceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.v1.PresenceService",
	HandlerType: (*PresenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdatePresence",
			Handler:    _PresenceService_UpdatePresence_Handler,
		},
		{
			MethodName: "Typing",
			Handler:    _PresenceService_Typing_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribePresence",
			Handler:       _PresenceService_SubscribePresence_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "session/service.proto",
}

const (
	ArchiveService_Search_FullMethodName = "/message.v1.ArchiveService/Search"
)

// ArchiveServiceClient is the client API for ArchiveService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========== 五、检索/归档（可选，按需实现） ==========
type ArchiveServiceClient interface {
	// 按标签/文本检索（结合 rich/embed/entity/automod）
	Search(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchResp, error)
}

type archiveServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewArchiveServiceClient(cc grpc.ClientConnInterface) ArchiveServiceClient {
	return &archiveServiceClient{cc}
}

func (c *archiveServiceClient) Search(ctx context.Context, in *SearchReq, opts ...grpc.CallOption) (*SearchResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResp)
	err := c.cc.Invoke(ctx, ArchiveService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArchiveServiceServer is the server API for ArchiveService service.
// All implementations must embed UnimplementedArchiveServiceServer
// for forward compatibility
//
// ========== 五、检索/归档（可选，按需实现） ==========
type ArchiveServiceServer interface {
	// 按标签/文本检索（结合 rich/embed/entity/automod）
	Search(context.Context, *SearchReq) (*SearchResp, error)
	mustEmbedUnimplementedArchiveServiceServer()
}

// UnimplementedArchiveServiceServer must be embedded to have forward compatible implementations.
type UnimplementedArchiveServiceServer struct {
}

func (UnimplementedArchiveServiceServer) Search(context.Context, *SearchReq) (*SearchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedArchiveServiceServer) mustEmbedUnimplementedArchiveServiceServer() {}

// UnsafeArchiveServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArchiveServiceServer will
// result in compilation errors.
type UnsafeArchiveServiceServer interface {
	mustEmbedUnimplementedArchiveServiceServer()
}

func RegisterArchiveServiceServer(s grpc.ServiceRegistrar, srv ArchiveServiceServer) {
	s.RegisterService(&ArchiveService_ServiceDesc, srv)
}

func _ArchiveService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArchiveService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServiceServer).Search(ctx, req.(*SearchReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ArchiveService_ServiceDesc is the grpc.ServiceDesc for ArchiveService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArchiveService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.v1.ArchiveService",
	HandlerType: (*ArchiveServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _ArchiveService_Search_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "session/service.proto",
}
